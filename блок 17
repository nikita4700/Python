{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5490e75c-115f-4e71-a606-a092c9dc99e8",
   "metadata": {},
   "outputs": [],
   "source": [
    "Описать рекурсивные функции Fact и Fact2, вычисляющие значения факториала  N!  и двойного факториала  N!!  соответственно ( N>0  — параметр целого типа)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "bd2ccc00-13a0-4497-8be9-a2087e5aeb29",
   "metadata": {},
   "outputs": [
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "введите n 4\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "24\n",
      "8\n"
     ]
    }
   ],
   "source": [
    "def Fact (n):\n",
    "    if n<=1:\n",
    "        return 1\n",
    "    else:\n",
    "        return n*Fact(n-1)\n",
    "\n",
    "\n",
    "def Fact2 (n):\n",
    "    if n <= 1:\n",
    "        return 1\n",
    "    elif n == 2:\n",
    "        return 2\n",
    "    else:\n",
    "        return n * Fact2(n - 2)\n",
    "n=int(input('введите n'))\n",
    "print (Fact(n)) \n",
    "print (Fact2(n))  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c54dcaf8-825c-4cee-967f-c709e7d7d8e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "Описать рекурсивную функцию PowerN, находящую значение  n -й степени числа  x  по формуле:\n",
    "x0=1,xn=x⋅xn−1приn>0,xn=1/x−nприn<0, \n",
    "\n",
    "где  x≥0  — вещественное число,  n  — целое."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "ee20590f-513a-4aed-8252-81fb06eb1fa1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "16\n"
     ]
    }
   ],
   "source": [
    "def PowerN (x,n):\n",
    "    if n == 0:\n",
    "        return 1\n",
    "    elif n > 0:\n",
    "        return x* PowerN(x, n - 1)\n",
    "    else:  # n < 0\n",
    "        return 1 / PowerN(x, -n)\n",
    "\n",
    "print (PowerN(2,4))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e0ab258d-70a2-4f99-92cb-194a05e4bbde",
   "metadata": {},
   "outputs": [],
   "source": [
    "Описать рекурсивную функцию SqrtK(x, k, n), находящую приближенное значение корня k-й степени из числа x по формуле:\n",
    "y(0)=1,y(n+1)=y(n)–y(n)–xyk–1(n)k,"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "8ef964f1-4de8-458f-b2bf-4738aec3fac5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "def SqrtK(x, k, n):\n",
    "    if n==0:\n",
    "        return 1\n",
    "    else:\n",
    "        y_prev = SqrtK(x, k, n-1)    # Получаем предыдущее приближение\n",
    "        # Вычисляем новое, более точное приближение\n",
    "        y_new = ((k-1)*y_prev + x/(y_prev**(k-1))) / k\n",
    "        return y_new\n",
    "print  (SqrtK(25, 2, 0) )      "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "7c36a751-5778-4f40-9f34-44e66cfc4e38",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Начинаем вычислять...\n",
      "2 3\n",
      "5 9\n",
      "13 25\n",
      "34 67\n",
      "89 177\n"
     ]
    }
   ],
   "source": [
    "count_calls = 0\n",
    "def FibRec(k):\n",
    "    global count_calls \n",
    "    count_calls += 1\n",
    "    if k==1 or k==2:\n",
    "        return 1\n",
    "    else:\n",
    "        return FibRec(k-2)+FibRec(k-1)\n",
    "ll = [3, 5, 7, 9, 11]  # ← вот эти 5 чисел!\n",
    "\n",
    "print(\"Начинаем вычислять...\")\n",
    "for i  in ll:\n",
    "    count_calls = 0\n",
    "    result = FibRec(i)  \n",
    "    print(result , count_calls )       \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "a099ea30-096c-4355-973d-f58c856fcbd5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "число 1 кол-во 1\n",
      "число 28 кол-во 55\n",
      "число 70 кол-во 139\n",
      "число 28 кол-во 55\n",
      "число 1 кол-во 1\n"
     ]
    }
   ],
   "source": [
    "count_calls=0\n",
    "def C(m, n):\n",
    "    global count_calls\n",
    "    count_calls+=1\n",
    "    if m==0 or m==n:\n",
    "        return 1\n",
    "    else:\n",
    "        return C(m, n-1)+C(m-1, n-1)\n",
    "N = 8\n",
    "M_list = [0, 2, 4, 6, 8]  # 5 значений\n",
    "\n",
    "# Выводим\n",
    "for M in M_list:\n",
    "    count_calls= 0\n",
    "    comb = C(M, N)\n",
    "    print('число',comb,'кол-во',count_calls)    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "1478b185-e725-4d73-85e4-5c6ed62d6414",
   "metadata": {},
   "outputs": [
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "введите число 56\n",
      "введите число 98\n",
      "введите число 126\n",
      "введите число 210\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "14\n",
      "14\n",
      "14\n"
     ]
    }
   ],
   "source": [
    "def NOD(A, B):\n",
    "    if A==0:\n",
    "        return B\n",
    "    elif A!=0:\n",
    "        return NOD(B%A, A)\n",
    "A=int(input('введите число'))\n",
    "B=int(input('введите число'))\n",
    "C=int(input('введите число'))\n",
    "D=int(input('введите число'))\n",
    "print(NOD(A, B))\n",
    "print(NOD(A, D))\n",
    "print(NOD(A, C))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "1742d749-3723-49b2-8d69-3963a9386fdb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Находим минимальные элементы трех массивов:\n",
      "Массив 1: [5, 2, 8, 1, 9, 3]\n",
      "Минимум: 1\n",
      "\n",
      "Массив 2: [-10, 0, 15, -3, 7]\n",
      "Минимум: -10\n",
      "\n",
      "Массив 3: [100, 50, 75, 25, 150, 10]\n",
      "Минимум: 10\n",
      "\n"
     ]
    }
   ],
   "source": [
    "def MinRec(A, N):\n",
    "    if N == 1:  # если остался один элемент\n",
    "        return A[0]  # вернуть его\n",
    "    \n",
    "    else:\n",
    "        # 1. Найти минимум в первых N-1 элементах\n",
    "        min_rest = MinRec(A, N-1)  # ← уходим в рекурсию!\n",
    "        \n",
    "        # 2. Взять последний элемент из рассматриваемой части\n",
    "        last_element = A[N-1]  # ← индекс последнего элемента\n",
    "        \n",
    "        # 3. Сравнить и вернуть меньший\n",
    "        if min_rest < last_element:\n",
    "            return min_rest\n",
    "        else:\n",
    "            return last_element\n",
    "array1 = [5, 2, 8, 1, 9, 3]\n",
    "array2 = [-10, 0, 15, -3, 7]\n",
    "array3 = [100, 50, 75, 25, 150, 10]\n",
    "\n",
    "print(\"Находим минимальные элементы трех массивов:\")\n",
    "\n",
    "# Массив 1\n",
    "min1 = MinRec(array1, len(array1))\n",
    "print(f\"Массив 1: {array1}\")\n",
    "print(f\"Минимум: {min1}\")\n",
    "print()\n",
    "\n",
    "# Массив 2\n",
    "min2 = MinRec(array2, len(array2))\n",
    "print(f\"Массив 2: {array2}\")\n",
    "print(f\"Минимум: {min2}\")\n",
    "print()\n",
    "\n",
    "# Массив 3\n",
    "min3 = MinRec(array3, len(array3))\n",
    "print(f\"Массив 3: {array3}\")\n",
    "print(f\"Минимум: {min3}\")\n",
    "print()\n",
    "\n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "a0d63f6f-0100-4d62-8cbb-287da659c32b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n"
     ]
    }
   ],
   "source": [
    "def Digits(S):\n",
    "    if S == \"\":  # если строка пустая\n",
    "        return 0\n",
    "    if S[0].isdigit():  # если первый символ - цифра\n",
    "        return 1 + Digits(S[1:])  # 1 + остаток\n",
    "    else:\n",
    "        return Digits(S[1:])\n",
    "S='cdcnfjk12'\n",
    "print(Digits(S))\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "33e0f3bf-e737-4768-bb70-3e92dd08debc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "False\n"
     ]
    }
   ],
   "source": [
    "def Simm (s):\n",
    "    \n",
    "    if len(S) <= 1:\n",
    "        return True\n",
    "    \n",
    "    # Базовый случай 2: если первый и последний символы не совпадают\n",
    "    if S[0] != S[-1]:\n",
    "        return False\n",
    "    \n",
    "    # Рекурсивный случай: проверяем внутреннюю часть строки\n",
    "    return Simm(S[1:-1])\n",
    "S='cdcnfjk12'\n",
    "print (Simm (S))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90f79929-b93e-4622-a029-799e7ff84d7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def binary_sum(a, b, carry=0):\n",
    "    if a == 0 and b == 0:\n",
    "        return '' if carry == 0 else '1'\n",
    "    last_a = a % 10\n",
    "    last_b = b % 10\n",
    "    s = last_a + last_b + carry\n",
    "    return binary_sum(a // 10, b // 10, s // 2) + str(s % 2)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b69e4729-0db3-4d22-a645-a68cef2a8cfe",
   "metadata": {},
   "outputs": [],
   "source": [
    "def Root(f, a, b, eps):\n",
    "    m = (a + b) / 2\n",
    "    if b - a < eps:\n",
    "        return m\n",
    "    if f(a) * f(m) < 0:\n",
    "        return Root(f, a, m, eps)\n",
    "    else:\n",
    "        return Root(f, m, b, eps)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fa7ce5c1-660a-44a8-a352-fcd9a1e211d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def reverse_digits(n, acc=0):\n",
    "    if n == 0:\n",
    "        return acc\n",
    "    return reverse_digits(n // 10, acc * 10 + n % 10)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "974dbcfa-22ac-4e07-af63-7262df487a14",
   "metadata": {},
   "outputs": [],
   "source": [
    "def Simm(S, i, j):\n",
    "    if i >= j:\n",
    "        return True\n",
    "    if S[i] != S[j]:\n",
    "        return False\n",
    "    return Simm(S, i + 1, j - 1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "279ac183-a069-466b-b1c0-092b715ac6a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def sum_digits(n):\n",
    "    if n == 0:\n",
    "        return 0\n",
    "    return n % 10 + sum_digits(n // 10)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1bdf54df-102d-41a3-a99c-05d0a67c178e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def is_palindrome(word, left=0, right=None):\n",
    "    if right is None:\n",
    "        right = len(word) - 1\n",
    "    if left >= right:\n",
    "        return \"yes\"\n",
    "    if word[left] != word[right]:\n",
    "        return \"no\"\n",
    "    return is_palindrome(word, left + 1, right - 1)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
